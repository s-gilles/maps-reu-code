#!/usr/bin/python2

from __future__ import print_function

import argparse
import errno
import csv
import sys

from snappy import *

# This is the `disposable' client.  Run it with args as specified (run
# without args for options) stdin, it accepts a filename. It then
# expects to receive manifold names, one afterthe other, on stdin. It
# will try to find the spanning of that manifold's dimensions
# (geometric and non-geometric) and output them to the filename
# (headers should be handled correctly).

LCC_READY_TO_RECEIVE_DATA_STRINGS = 'LCC_I_am_ready_for_data'
LCC_MAKING_PROGRESS = 'LCC_I_am_making_progress'
LCC_WANT_MORE_DATA = 'LCC_ready_for_more_data'
LCC_ENCOUNTERED_ERROR = 'LCC_encountered_an_error'
LCC_REFUSE_TO_CLOBBER = 'LCC_output_file_exists_and_is_not_what_was_expected'
LCC_CANT_DEAL_WITH_OUTPUT_FILE = 'LCC_output_file_cannot_be_gracefully_dealt_with'
LCC_HEADER = 'Manifold;TraceField;TraceFieldDegree;Subfield;SubfieldDegree;Root;Volume;LinearCombination'

class Span:

    polynomial_string = None
    """The string defining the field of this span. Example 'x^7-3*x^6+5*x^5-5*x^4+2*x^3-2*x+1'"""

    number_of_complex_places = None
    """The number of complex places of polynomial_string. Example 2"""

    root = None
    """Each span represents a specific complex root of the polynomial with positive imaginary coefficient. Example '0.123338470+1.00512926*I'"""

    span_dimension = None
    """How many elements are in the volume span. Example: 1"""

    volume_span = None
    """A list, with span_dimension elements, which defines a linearly
    independent subset of the volumes detected for this polynomial and
    root.

    Example: ['7.53260450387045224483849916956535836']

    """

    manifold_span = None
    """A list, with span_dimension elements, such that each manifold has
    the geometric volume of the corresponding entry in volume_span.

    Example: ['10^3_17(-1,1)(4,1)(3,1)']

    """

    fit_ratio = None
    """An integer representing how well the manifold_span matched observed
    data. If, for example, the lattice of detected volumes contains
    9*x and 10*x, yet the smallest volume found is 5*x, the (if the
    lattice is really generated by geometric volumes of manifolds)
    there must be a manifold with volume x, yet such could not be
    obtained - the best is a manifold with volume 5*x. So the
    fit_ratio would be 5.

    Example: 1

    """


    def __init__(self, _polynomial, _number_of_complex_places, _root,
                 _span_dimension, _volume_span, _manifold_span,
                 _fit_ratio):
        """Constructor"""
        self.polynomial = _polynomial
        self.number_of_complex_places = int(_number_of_complex_places)
        self.root = _root
        self.span_dimension = int(_span_dimension)
        self.volume_span = eval(_volume_span)
        self.manifold_span = eval(_manifold_span)
        self.fit_ratio = int(_fit_ratio)

        # For speed, don't check anything here, although we could
        # assert that len(volume_span) == span_dimension, that
        # everything in manifold_span is a valid manifold, etc. etc.


all_spans = []
"""A list of every span read in.  Dunno why"""

span_dict = dict()
"""A lookup of spans by polynomial, then root"""

output_filename = None
"""Where to write out data"""

n = 2
"""Which SL(n,C) to consider representations into"""

lindep_precision = 16
"""How much precision to ask Pari to use"""

epsilon_string = '1E-500'
"""Very small number for use in volume culling"""

def nfsubfields(polynomial):
    done = False
    nfsubfields_output = []
    polredabs_output = None
    while True:
        try:
            if not polredabs_output:
                polredabs_output = pari(polynomial).polredabs()
            nfsubfields_output = polredabs_output.nfsubfields()[1:]
            break
        except:
            pari.allocatemem()

    return nfsubfields_output

def handle_manifold(a_string):
    m = Manifold(a_string)
    pv = m.ptolemy_variety(n, 'all')
    decompositions = pv.retrieve_decomposition()
    subfields = None

    for decomposition in decompositions:
        obstruction_class = -1
        for s in decomposition:
            obstruction_class = obstruction_class + 1
            polynomial = s.number_field().replace(' ', '')
            volumes = s.solutions(numerical = True).volume_numerical()
            if not volumes:
                volumes = []

            # First, prune tiny volumes
            volumes = [ v for v in volumes if pari(str(v)+'>'+epsilon_string) ]

            # Second, ensure that there are not more than 4 = 8/2
            # volumes, as this would indicate a field we aren't
            # prepared to deal with.
            volumes = [ str(v) for v in volumes ]
            positives = set([ v.replace('-', '') for v in volumes
                              if pari(v+'>'+epsilon_string) ])
            distinct_volumes = list()
            for v in positives:
                matches = [ u for u in good if pari(str(v)+'-'+str(u)+'<='+epsilon_string) ]
                if not matches:
                    distinct_volumes.append(v)
            if len(distinct_volumes) > 4:
                continue

            # Now we need to do something....


if __name__ == '__main__':

    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('--spanfile', '-s',
                            default = 'spans.csv',
                            help = 'Path of master list of spans for reading')
    arg_parser.add_argument('--output', '-o',
                            default = 'linear_combinations.csv',
                            help = 'Output path (appending handled well)')
    arg_parser.add_argument('-n',
                            default = '2',
                            metavar = 'n',
                            help = 'For considering SL(n,C)')
    arg_parser.add_argument('--precision', '-p',
                            type = int,
                            default = 500,
                            help = 'Precision to set PARI to')
    arg_parser.add_argument('--lindep-precision', '-l',
                            type = int,
                            default = 16,
                            help = 'Precision to use when calling lindep()')
    args = arg_parser.parse_args()
    output_filename = args.output
    n = args.n
    if args.precision < 20:
        args.precision = 20
    pari.set_real_precision(args.precision)
    epsilon_string = '1E-'+str(args.precision)
    lindep_precision = args.lindep_precision

    # Figure out how to handle the output file - should we append the
    # header or not?
    has_header = False
    must_abort = False

    try:
        with open(output_filename, 'rb') as output_file:
            firstline = output_file.readline().rstrip()
            if firstline:
                if firstline == LCC_HEADER:
                    has_header = True
                else:
                    print(LCC_REFUSE_TO_CLOBBER)
                    must_abort = True
    except IOError as e:
        if e.errno == errno.ENOENT:
            pass
        else:
            print(LCC_CANT_DEAL_WITH_OUTPUT_FILE)
            must_abort = True
    except:
        print(LCC_CANT_DEAL_WITH_OUTPUT_FILE)
        must_abort = True

    if must_abort:
        sys.exit(1)

    if not has_header:
        with open(output_filename, 'a') as output_file:
            output_file.write(LCC_HEADER)
            output_file.write('\n')

    # Now the output file has the header. Note that a handle is not
    # kept because this process could be killed at any time, so as
    # close to atomicity as possible is desired.

    with open(args.spanfile, 'rb') as span_file:
        reader = csv.reader(span_file, delimiter=';', quoting = csv.QUOTE_ALL)
        header = reader.next()
        for row in reader:
            new_span = Span(*row)
            all_spans.append(Span(*row))

            by_dict = span_dict.setdefault(new_span.polynomial, dict())
            by_root = by_dict.setdefault(new_span.root, list())
            by_root.append(new_span)


    print(LCC_READY_TO_RECEIVE_DATA_STRINGS)

    while True:
        handle_manifold(sys.stdin.readline())
        print(LCC_WANT_MORE_DATA)
